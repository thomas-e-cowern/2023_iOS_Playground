//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Atomics open source project
//
// Copyright (c) 2020 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
%{
  from gyb_utils import *

  integerTypes = [
    # Swift        Storage64       Storage32
    ("Int8",       "Int8",         "Int8"),
    ("Int16",      "Int16",        "Int16"),
    ("Int32",      "Int32",        "Int32"),
    ("Int64",      "Int64",        "Int64"),
    ("UInt8",      "Int8",         "Int8"),
    ("UInt16",     "Int16",        "Int16"),
    ("UInt32",     "Int32",        "Int32"),
    ("UInt64",     "Int64",        "Int64"),
    ("Int",        "Int",          "Int"),
    ("UInt",       "Int",          "Int"),
    ("DoubleWord", "DoubleWord",   "Int64"),
  ]
}%
${autogenerated_warning()}

#if ATOMICS_NATIVE_BUILTINS
import Swift
#else
import _AtomicsShims
#endif

% for swiftType, storage64, storage32 in integerTypes:
%   for (variant, storageType) in bitwidth_variants(storage64, storage32):
%{
   def decode(name):
     if swiftType == storageType:
       return name
     if swiftType == "U" + storageType:
       return swiftType + "(bitPattern: " + name + ")"
     if swiftType == "Int" or swiftType == "UInt":
       return swiftType + "(" + name + "._value)"
     return "unsafeBitCast(" + name + ", to: " + swiftType + ".self)"

   def encode(name):
     if swiftType == storageType:
       return name
     if swiftType == "U" + storageType:
       return storageType + "(bitPattern: " + name + ")"
     if swiftType == "Int" or swiftType == "UInt":
       return storageType + "(" + name + "._value)"
     return "unsafeBitCast(" + name + ", to: " + storageType + ".self)"
}%

${archConditionStart(variant)}
extension ${swiftType}: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = ${swiftType}

#if ATOMICS_NATIVE_BUILTINS
    @usableFromInline
    internal typealias _Storage = ${storageType}
#else
    @usableFromInline
    internal typealias _Storage = _Atomic${storageType}Storage
#endif

    @usableFromInline
    internal var _storage: _Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
#if ATOMICS_NATIVE_BUILTINS
      _storage = ${encode("value")}
#else
      _storage = _sa_prepare_${storageType}(${encode("value")})
#endif
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
#if ATOMICS_NATIVE_BUILTINS
      return ${decode("_storage")}
#else
      let v = _sa_dispose_${storageType}(_storage)
      return ${decode("v")}
#endif
    }
  }
}

extension UnsafeMutablePointer
where Pointee == ${swiftType}.AtomicRepresentation {
  @inlinable @inline(__always)
  internal var _extract: UnsafeMutablePointer<Pointee._Storage> {
    // `${swiftType}.AtomicRepresentation` is layout-compatible with
    // its only stored property.
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
}

extension ${swiftType}.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> ${swiftType} {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return ${decode("r")}
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: ${swiftType},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    pointer._extract._atomicStore(
      ${encode("desired")},
      ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: ${swiftType},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> ${swiftType} {
    let r = pointer._extract._atomicExchange(
      ${encode("desired")},
      ordering: ordering)
    return ${decode("r")}
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: ${swiftType},
    desired: ${swiftType},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: ${swiftType}) {
    let r = pointer._extract._atomicCompareExchange(
      expected: ${encode("expected")},
      desired: ${encode("desired")},
      ordering: ordering)
    return (r.exchanged, ${decode("r.original")})
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: ${swiftType},
    desired: ${swiftType},
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: ${swiftType}) {
    let r = pointer._extract._atomicCompareExchange(
      expected: ${encode("expected")},
      desired: ${encode("desired")},
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, ${decode("r.original")})
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: ${swiftType},
    desired: ${swiftType},
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: ${swiftType}) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: ${encode("expected")},
      desired: ${encode("desired")},
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, ${decode("r.original")})
  }
}

% if swiftType != "DoubleWord":
extension ${swiftType}: AtomicInteger {}

extension ${swiftType}.AtomicRepresentation: AtomicIntegerStorage {
% for (name, cname, op, label, doc) in integerOperations:
% defaultValue = " = 1" if label != "" else ""
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  @discardableResult
  public static func atomicLoadThen${name}(
    ${label} operand: ${swiftType}${defaultValue},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> ${swiftType} {
    let r = pointer._extract._atomicLoadThen${name}(
      ${argLabel(label)}${encode("operand")}, ordering: ordering)
    return ${decode("r")}
  }

% end
}

% end
${archConditionEnd(variant)}

%   end
% end
